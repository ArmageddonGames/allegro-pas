@shorttitle(Introduction)
@title(Allegro.pas)

@section(1 intro Introduction)

  Allegro.pas is a wrapper to allow Pascal compilers (such as Free Pascal or
  Delphi) to use the Allegro library.

  This version is a SVN version.  It has a lot of things that just don't work
  or that will change in the near future.  Please see
  @link(objectives section "Objectives") for a brief description of the goals.

  Read @link(use section "How to use Allegro.pas") for a description of the
  main module of the library.

  If you want to collaborate please join the main Allegro.pas mailing list
  (http://sourceforge.net/mailarchive/forum.php?forum_name=allegro-pas-main).


@section(1 objectives Objectives of version 4.3.0)

  @unorderedList(
    @item(@bold(Make it run on Linux).  Previous versions work only on
      MS-Windows system.  @bold(This goal is complete).  It would be great to
      introduce other systems as MacOS X and others @(and should be easy as
      basis is complete@) but I haven't another system.)
    @item(@bold(Define a new API more Pascal-like).  Previous versions have a
      C-like one with lots of pointers and other ugly issues.)
    @item(Add a lot of new functionality as @bold(UNICODE support).)
    @item(@bold(Implement a Grabber utility) to create and manage
      @link(aldtfile data files).)
    @item(@bold(Add support for OpenGL hardware accelerated graphics) via
      AllegroGL add-on.)
  )

@section(1 use How to use Allegro.pas)

  The best way to start with Allegro.pas is to study the sources at examples
  and look for detailed description of procedures and functions at the
  documentation.  That examples are fully commented and should be easy to
  understand.

  Anyway, here you have a description of the main modules of the library:

  @unorderedList(
    @item(@bold(@link(init Initialization and finalization)))
    @item(@bold(@link(unicode UNICODE routines)))
    @item(@bold(@link(configuration Configuration routines)))
    @item(@bold(@link(timer Timer routines)))
    @item(@bold(@link(keyboard Keyboard routines)))
    @item(@bold(@link(joystick Joystick support)))
    @item(@bold(@link(color Color)))
    @item(@bold(@link(bitmap Bitmaps)))
  )

@section(2 init Initialization and finalization)

  You @bold(must) call either @link(al_install) or @link(al_init) before doing
  anything other than using the @link(unicode UNICODE routines).

  On the other hand, you @bold(must) call @link(al_exit) before to finish the
  program.


@section(2 unicode UNICODE routines)

  Allegro can manipulate and display text using any character values from 0
  right up to 2^32-1 (although the current implementation of the grabber can
  only create fonts using characters up to 2^16-1).  You can choose between a
  number of different text encoding formats, which controls how strings are
  stored and how Allegro interprets strings that you pass to it, using the
  @link(al_set_uformat) procedure.  This setting affects all aspects of the
  system:  whenever you see a function that returns a @code(STRING) or
  @code(PCHAR) type, or that takes the same as an argument, that text will be
  in whatever format you have told Allegro to use.

  By default, Allegro uses UTF-8 encoded text (@code(AL_U_UTF8)).  This is a
  variable-width format, where characters can occupy anywhere from one to four
  bytes.  The nice thing about it is that characters ranging from 0-127 are
  encoded directly as themselves, so UTF-8 is upwardly compatible with 7-bit
  ASCII (@code('Hello, World!') means the same thing regardless of whether you
  interpret it as ASCII or UTF-8 data).  Any character values above 128, such
  as accented vowels, the UK currency symbol, and Arabic or Chinese characters,
  will be encoded as a sequence of two or more bytes, each in the range
  128-255.  This means you will never get what looks like a 7-bit ASCII
  character as part of the encoding of a different character value, which makes
  it very easy to manipulate UTF-8 strings.

  There are a few editing programs that understand UTF-8 format text files.
  Alternatively, you can write your strings in plain ASCII or 16-bit Unicode
  formats, and then use the Allegro textconv program to convert them into
  UTF-8.

  If you prefer to use some other text format, you can set Allegro to work with
  normal 8-bit ASCII (@code(AL_U_ASCII)), or 16-bit Unicode (@code(U_UNICODE))
  instead, or you can provide some handler functions to make it support
  whatever other text encoding you like (for example it would be easy to add
  support for 32 bit UCS-4 characters, or the Chinese GB-code format).

  There is some limited support for alternative 8-bit codepages, via the
  @code(AL_U_ASCII_CP) mode.  This is very slow, so you shouldn't use it for
  serious work, but it can be handy as an easy way to convert text between
  different codepages.  By default the @code(AL_U_ASCII_CP) mode is set up to
  reduce text to a clean 7-bit ASCII format, trying to replace any accented
  vowels with their simpler equivalents (this is used by the @link(al_message)
  function when it needs to print an error report onto a text mode DOS screen).
  If you want to work with other codepages, you can do this by passing a
  character mapping table to the @link(al_set_ucodepage) function.

  Note that you can use the Unicode routines before you call @link(al_install)
  or @link(al_init).  If you want to work in a text mode other than UTF-8, it
  is best to set it with @link(al_set_uformat) just before you call these.

@section(2 configuration Configuration routines)

  Various parts of Allegro, such as the sound routines and the
  @link(al_load_joystick_data) function, require some configuration
  information.  This data is stored in text files as a collection of
  @code(variable=value) lines, along with comments that begin with a @code(#)
  character and continue to the end of the line.  The configuration file may
  optionally be divided into sections, which begin with a @code([sectionname])
  line.  Each section has a unique namespace, to prevent variable name
  conflicts, but any variables that aren't in a section are considered to
  belong to all the sections simultaneously.

  Note that variable and section names cannot contain spaces.

  By default the configuration data is read from a file called
  @code(allegro.cfg), which can be located either in the same directory as the
  program executable, or the directory pointed to by the @code(ALLEGRO)
  environment variable.  Under Unix, it also checks for @code(~/allegro.cfg),
  @code(~/.allegrorc), @code(/etc/allegro.cfg), and @code(/etc/allegrorc), in
  that order;  under BeOS only the last two are also checked.  MacOS X also
  checks in the Contents/Resources directory of the application bundle, if any,
  before doing the checks above.

  If you don't like this approach, you can specify any filename you like with
  using procedure @link(al_set_config_file), or use a block of binary
  configuration data with @link(al_set_config_data) provided by your program
  (which could for example be loaded from a @link(datafile)).

  You can store whatever custom information you like in the config file, along
  with the standard variables that are used by Allegro.  Allegro comes with a
  @code(tools/setup) directory where you can find configuration programs.  The
  standalone setup program is likely to be of interest to final users.  It
  allows any user to create an @code(allegro.cfg) file without the need to
  touch a text editor and enter values by hand.  It also provides a few basic
  tests like sound playing for sound card testing.  You are welcome to include
  the setup program with your game, either as is or with modified graphics to
  fit better your game.

@section(2 timer Timer routines)

  Allegro can set up several virtual timer functions, all going at different
  speeds.

  They are usually implemented using threads, which run parallel to the main
  thread.  Therefore timer callbacks on such platforms will not block the main
  thread when called, so you may need to use appropriate synchronisation
  devices (eg. mutexes, semaphores, etc.) when accessing data that is shared by
  a callback and the main thread.  (Currently Allegro does not provide such
  devices.)

  @bold(See also) @link(al_install_int)

@section(2 keyboard Keyboard routines)

  The Allegro keyboard handler provides both buffered input (@link(al_readkey))
  and a set of flags storing the current state of each key (@link(al_key)).
  Note that it is not possible to correctly detect every combination of keys,
  due to the design of the PC keyboard.  Up to two or three keys at a time will
  work fine, but if you press more than that the extras are likely to be
  ignored (exactly which combinations are possible seems to vary from one
  keyboard to another).

  Allegro comes with a prepackaged @code(keyboard.dat) file at the
  @code(tools/setup) directory which you can put along with your binary.  If
  this file is present, Allegro will be able to extract the keyboard mapping
  information stored there.  However, the end user still needs to select which
  keyboard mapping to use.  This can be accomplished through the keyboard
  variable of the system section in a standard @code(allegro.cfg) configuration
  file.  Read section about @link(configuration) for more information about
  this.

  @bold(See also) @link(al_install_keyboard)

@section(2 joystick Joystick support)

  Unlike keyboard or mouse input, which are usually read through hardware
  interrupts by Allegro, joystick input functions have to be polled because
  there are no hardware interrupts for them on most platforms.  This doesn't
  mean that you have to poll the joysticks on each line of code you want to

  frame in your game loop.  Otherwise you face the possibility of reading stale
  incorrect data.

  @bold(See also) @link(al_install_joystick)

@section(2 color Color)

  All the Allegro drawing functions use integer parameters to represent colors.

  In 256-color mode the color values are treated as indexes into the current
  palette, which is a table listing the red, green and blue intensities for
  each of the 256 possible colors.

  Palette entries are stored in an @link(AL_RGB) structure, which contains red,
  green and blue intensities in the VGA hardware format, ranging from 0-63.
  The full palette is an @link(AL_PALETTE), a list of f256 @code(AL_RGB)
  values.  You can set the palette using the @link(al_set_palette) procedure.

  In a truecolor video mode the red, green, and blue components for each pixel
  are packed directly into the color value, rather than using a palette lookup
  table.  In a 15-bit mode there are 5 bits for each color, in 16-bit modes
  there are 5 bits each of red and blue and six bits of green, and both 24 and
  32-bit modes use 8 bits for each color (the 32-bit pixels simply have an
  extra padding byte to align the data nicely).  The layout of these components
  can vary depending on your hardware, but will generally either be RGB or BGR.
  Since the layout is not known until you select the video mode you will be
  using, you must call @link(al_set_gfx_mode) before using any of the color
  routines!

@section(2 bitmap Bitmaps)

  Once you have selected a graphics mode, you can draw things onto the display
  via the @link(al_screen) bitmap.  All the Allegro graphics routines draw onto
  @link(AL_BITMAP) structures, which are areas of memory containing rectangular
  images, stored as packed byte arrays (in 8-bit modes one byte per pixel, in
  15- and 16-bit modes two bytes per pixel, in 24-bit modes 3 bytes per pixel
  and in 32-bit modes 4 bytes per pixel).  You can create and manipulate
  bitmaps in system RAM, or you can write to the special @code(al_screen)
  bitmap which represents the video memory in your graphics card.

  Allegro supports several different types of bitmaps:
  @unorderedList(
    @item(The @link(al_screen) bitmap, which represents the hardware video
	memory.  Ultimately you have to draw onto this in order for your image
	to be visible.  It is destroyed by any subsequent calls to
	@link(al_set_gfx_mode), so you should never attempt to destroy it
	yourself.)
    @item(Memory bitmaps, which are located in system RAM and can be used to
	store graphics or as temporary drawing spaces for double buffered
	systems.  These can be obtained by calling @link(al_create_bitmap),
	@link(al_load_bitmap), or by loading a grabber datafile.)
    @item(Sub-bitmaps.  These share image memory with a parent bitmap (which
	can be the screen, a video or system bitmap, a memory bitmap, or
	another sub-bitmap), so drawing onto them will also change their
	parent.  They can be of any size and located anywhere within the parent
	bitmap, and can have their own clipping rectangles, so they are a
	useful way of dividing a bitmap into several smaller units, eg.
	splitting a large virtual screen into multiple sections.
	@bold(Warning:) Make sure not to destroy a bitmap before all of its
	sub-bitmaps, otherwise bad things will happen when you try to access
	one of these sub-bitmaps.  Are created by the
	@link(al_create_sub_bitmap) function.)
    @item(Video memory bitmaps.  These are created by the
	@link(al_create_video_bitmap) function, and are usually implemented as
	sub-bitmaps of the screen object.  They must be destroyed by
	@link(al_destroy_bitmap) before any subsequent calls to
	@code(al_set_gfx_mode).)
    @item(System bitmaps.  These are created by the
	@link(al_create_system_bitmap) function, and are a sort of halfway
	house between memory and video bitmaps.  They live in system memory,
	so you aren't limited by the amount of video ram in your card, but they
	are stored in a platform-specific format that may enable better
	hardware acceleration than is possible with a normal memory bitmap (see
	the @link(AL_GFX_HW_SYS_TO_VRAM_BLIT) and
	@link(AL_GFX_HW_SYS_TO_VRAM_BLIT_MASKED) flags in
	@link(al_gfx_capabilities)).  System bitmaps must be accessed in the
	same way as video bitmaps, using the bank switch functions and
	@code(bmp_write* ) macros.  Not every platform implements this type of
	bitmap:  if they aren't available, @code(al_create_system_bitmap) will
	function identically to @code(al_create_bitmap).  They must be
	destroyed by @code(al_destroy_bitmap) before any subsequent calls to
	@code(al_set_gfx_mode).)
    )

@section(1 contact Contact)

  If you want to contact me, please use the Allegro.pas main mail-list
  (http://sourceforge.net/mailarchive/forum.php?forum_name=allegro-pas-main).
